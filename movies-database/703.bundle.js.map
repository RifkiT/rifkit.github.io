{"version":3,"file":"703.bundle.js","mappings":"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","sources":["webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-row-align.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-row-column.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-rows-columns.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-start.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-template-areas.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-template.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/grid-utils.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/image-rendering.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/image-set.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/inline-logical.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/intrinsic.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/justify-content.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/mask-border.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/mask-composite.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/order.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/overscroll-behavior.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/pixelated.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/place-self.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/placeholder-shown.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/placeholder.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/print-color-adjust.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/text-decoration-skip-ink.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/text-decoration.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/text-emphasis-position.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/transform-decl.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/user-select.js","webpack://movies-detail-app/./node_modules/autoprefixer/lib/hacks/writing-mode.js"],"sourcesContent":["let Declaration = require('../declaration')\n\nclass GridRowAlign extends Declaration {\n  /**\n   * Do not prefix flexbox values\n   */\n  check(decl) {\n    return !decl.value.includes('flex-') && decl.value !== 'baseline'\n  }\n\n  /**\n   * Change property name for IE\n   */\n  prefixed(prop, prefix) {\n    return prefix + 'grid-row-align'\n  }\n\n  /**\n   * Change IE property back\n   */\n  normalize() {\n    return 'align-self'\n  }\n}\n\nGridRowAlign.names = ['grid-row-align']\n\nmodule.exports = GridRowAlign\n","let Declaration = require('../declaration')\nlet utils = require('./grid-utils')\n\nclass GridRowColumn extends Declaration {\n  /**\n   * Translate grid-row / grid-column to separate -ms- prefixed properties\n   */\n  insert(decl, prefix, prefixes) {\n    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)\n\n    let values = utils.parse(decl)\n    let [start, span] = utils.translate(values, 0, 1)\n\n    let hasStartValueSpan = values[0] && values[0].includes('span')\n\n    if (hasStartValueSpan) {\n      span = values[0].join('').replace(/\\D/g, '')\n    }\n\n    ;[\n      [decl.prop, start],\n      [`${decl.prop}-span`, span]\n    ].forEach(([prop, value]) => {\n      utils.insertDecl(decl, prop, value)\n    })\n\n    return undefined\n  }\n}\n\nGridRowColumn.names = ['grid-row', 'grid-column']\n\nmodule.exports = GridRowColumn\n","let Declaration = require('../declaration')\nlet {\n  prefixTrackProp,\n  prefixTrackValue,\n  autoplaceGridItems,\n  getGridGap,\n  inheritGridGap\n} = require('./grid-utils')\nlet Processor = require('../processor')\n\nclass GridRowsColumns extends Declaration {\n  /**\n   * Change property name for IE\n   */\n  prefixed(prop, prefix) {\n    if (prefix === '-ms-') {\n      return prefixTrackProp({ prop, prefix })\n    }\n    return super.prefixed(prop, prefix)\n  }\n\n  /**\n   * Change IE property back\n   */\n  normalize(prop) {\n    return prop.replace(/^grid-(rows|columns)/, 'grid-template-$1')\n  }\n\n  insert(decl, prefix, prefixes, result) {\n    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)\n\n    let { parent, prop, value } = decl\n    let isRowProp = prop.includes('rows')\n    let isColumnProp = prop.includes('columns')\n\n    let hasGridTemplate = parent.some(\n      i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'\n    )\n\n    /**\n     * Not to prefix rows declaration if grid-template(-areas) is present\n     */\n    if (hasGridTemplate && isRowProp) {\n      return false\n    }\n\n    let processor = new Processor({ options: {} })\n    let status = processor.gridStatus(parent, result)\n    let gap = getGridGap(decl)\n    gap = inheritGridGap(decl, gap) || gap\n\n    let gapValue = isRowProp ? gap.row : gap.column\n\n    if ((status === 'no-autoplace' || status === true) && !hasGridTemplate) {\n      gapValue = null\n    }\n\n    let prefixValue = prefixTrackValue({\n      value,\n      gap: gapValue\n    })\n\n    /**\n     * Insert prefixes\n     */\n    decl.cloneBefore({\n      prop: prefixTrackProp({ prop, prefix }),\n      value: prefixValue\n    })\n\n    let autoflow = parent.nodes.find(i => i.prop === 'grid-auto-flow')\n    let autoflowValue = 'row'\n\n    if (autoflow && !processor.disabled(autoflow, result)) {\n      autoflowValue = autoflow.value.trim()\n    }\n    if (status === 'autoplace') {\n      /**\n       * Show warning if grid-template-rows decl is not found\n       */\n      let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')\n\n      if (!rowDecl && hasGridTemplate) {\n        return undefined\n      } else if (!rowDecl && !hasGridTemplate) {\n        decl.warn(\n          result,\n          'Autoplacement does not work without grid-template-rows property'\n        )\n        return undefined\n      }\n\n      /**\n       * Show warning if grid-template-columns decl is not found\n       */\n      let columnDecl = parent.nodes.find(i => {\n        return i.prop === 'grid-template-columns'\n      })\n      if (!columnDecl && !hasGridTemplate) {\n        decl.warn(\n          result,\n          'Autoplacement does not work without grid-template-columns property'\n        )\n      }\n\n      /**\n       * Autoplace grid items\n       */\n      if (isColumnProp && !hasGridTemplate) {\n        autoplaceGridItems(decl, result, gap, autoflowValue)\n      }\n    }\n\n    return undefined\n  }\n}\n\nGridRowsColumns.names = [\n  'grid-template-rows',\n  'grid-template-columns',\n  'grid-rows',\n  'grid-columns'\n]\n\nmodule.exports = GridRowsColumns\n","let Declaration = require('../declaration')\n\nclass GridStart extends Declaration {\n  /**\n   * Do not add prefix for unsupported value in IE\n   */\n  check(decl) {\n    let value = decl.value\n    return !value.includes('/') && !value.includes('span')\n  }\n\n  /**\n   * Return a final spec property\n   */\n  normalize(prop) {\n    return prop.replace('-start', '')\n  }\n\n  /**\n   * Change property name for IE\n   */\n  prefixed(prop, prefix) {\n    let result = super.prefixed(prop, prefix)\n    if (prefix === '-ms-') {\n      result = result.replace('-start', '')\n    }\n    return result\n  }\n}\n\nGridStart.names = ['grid-row-start', 'grid-column-start']\n\nmodule.exports = GridStart\n","let Declaration = require('../declaration')\nlet {\n  parseGridAreas,\n  warnMissedAreas,\n  prefixTrackProp,\n  prefixTrackValue,\n  getGridGap,\n  warnGridGap,\n  inheritGridGap\n} = require('./grid-utils')\n\nfunction getGridRows(tpl) {\n  return tpl\n    .trim()\n    .slice(1, -1)\n    .split(/[\"']\\s*[\"']?/g)\n}\n\nclass GridTemplateAreas extends Declaration {\n  /**\n   * Translate grid-template-areas to separate -ms- prefixed properties\n   */\n  insert(decl, prefix, prefixes, result) {\n    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)\n\n    let hasColumns = false\n    let hasRows = false\n    let parent = decl.parent\n    let gap = getGridGap(decl)\n    gap = inheritGridGap(decl, gap) || gap\n\n    // remove already prefixed rows\n    // to prevent doubling prefixes\n    parent.walkDecls(/-ms-grid-rows/, i => i.remove())\n\n    // add empty tracks to rows\n    parent.walkDecls(/grid-template-(rows|columns)/, trackDecl => {\n      if (trackDecl.prop === 'grid-template-rows') {\n        hasRows = true\n        let { prop, value } = trackDecl\n        trackDecl.cloneBefore({\n          prop: prefixTrackProp({ prop, prefix }),\n          value: prefixTrackValue({ value, gap: gap.row })\n        })\n      } else {\n        hasColumns = true\n      }\n    })\n\n    let gridRows = getGridRows(decl.value)\n\n    if (hasColumns && !hasRows && gap.row && gridRows.length > 1) {\n      decl.cloneBefore({\n        prop: '-ms-grid-rows',\n        value: prefixTrackValue({\n          value: `repeat(${gridRows.length}, auto)`,\n          gap: gap.row\n        }),\n        raws: {}\n      })\n    }\n\n    // warnings\n    warnGridGap({\n      gap,\n      hasColumns,\n      decl,\n      result\n    })\n\n    let areas = parseGridAreas({\n      rows: gridRows,\n      gap\n    })\n\n    warnMissedAreas(areas, decl, result)\n\n    return decl\n  }\n}\n\nGridTemplateAreas.names = ['grid-template-areas']\n\nmodule.exports = GridTemplateAreas\n","let Declaration = require('../declaration')\nlet {\n  parseTemplate,\n  warnMissedAreas,\n  getGridGap,\n  warnGridGap,\n  inheritGridGap\n} = require('./grid-utils')\n\nclass GridTemplate extends Declaration {\n  /**\n   * Translate grid-template to separate -ms- prefixed properties\n   */\n  insert(decl, prefix, prefixes, result) {\n    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)\n\n    if (decl.parent.some(i => i.prop === '-ms-grid-rows')) {\n      return undefined\n    }\n\n    let gap = getGridGap(decl)\n\n    /**\n     * we must insert inherited gap values in some cases:\n     * if we are inside media query && if we have no grid-gap value\n     */\n    let inheritedGap = inheritGridGap(decl, gap)\n\n    let { rows, columns, areas } = parseTemplate({\n      decl,\n      gap: inheritedGap || gap\n    })\n\n    let hasAreas = Object.keys(areas).length > 0\n    let hasRows = Boolean(rows)\n    let hasColumns = Boolean(columns)\n\n    warnGridGap({\n      gap,\n      hasColumns,\n      decl,\n      result\n    })\n\n    warnMissedAreas(areas, decl, result)\n\n    if ((hasRows && hasColumns) || hasAreas) {\n      decl.cloneBefore({\n        prop: '-ms-grid-rows',\n        value: rows,\n        raws: {}\n      })\n    }\n\n    if (hasColumns) {\n      decl.cloneBefore({\n        prop: '-ms-grid-columns',\n        value: columns,\n        raws: {}\n      })\n    }\n\n    return decl\n  }\n}\n\nGridTemplate.names = ['grid-template']\n\nmodule.exports = GridTemplate\n","let parser = require('postcss-value-parser')\nlet list = require('postcss').list\n\nlet uniq = require('../utils').uniq\nlet escapeRegexp = require('../utils').escapeRegexp\nlet splitSelector = require('../utils').splitSelector\n\nfunction convert(value) {\n  if (\n    value &&\n    value.length === 2 &&\n    value[0] === 'span' &&\n    parseInt(value[1], 10) > 0\n  ) {\n    return [false, parseInt(value[1], 10)]\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false]\n  }\n\n  return [false, false]\n}\n\nexports.translate = translate\n\nfunction translate(values, startIndex, endIndex) {\n  let startValue = values[startIndex]\n  let endValue = values[endIndex]\n\n  if (!startValue) {\n    return [false, false]\n  }\n\n  let [start, spanStart] = convert(startValue)\n  let [end, spanEnd] = convert(endValue)\n\n  if (start && !endValue) {\n    return [start, false]\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart]\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd]\n  }\n\n  if (start && end) {\n    return [start, end - start]\n  }\n\n  return [false, false]\n}\n\nexports.parse = parse\n\nfunction parse(decl) {\n  let node = parser(decl.value)\n\n  let values = []\n  let current = 0\n  values[current] = []\n\n  for (let i of node.nodes) {\n    if (i.type === 'div') {\n      current += 1\n      values[current] = []\n    } else if (i.type === 'word') {\n      values[current].push(i.value)\n    }\n  }\n\n  return values\n}\n\nexports.insertDecl = insertDecl\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {\n    decl.cloneBefore({\n      prop: `-ms-${prop}`,\n      value: value.toString()\n    })\n  }\n}\n\n// Track transforms\n\nexports.prefixTrackProp = prefixTrackProp\n\nfunction prefixTrackProp({ prop, prefix }) {\n  return prefix + prop.replace('template-', '')\n}\n\nfunction transformRepeat({ nodes }, { gap }) {\n  let { count, size } = nodes.reduce(\n    (result, node) => {\n      if (node.type === 'div' && node.value === ',') {\n        result.key = 'size'\n      } else {\n        result[result.key].push(parser.stringify(node))\n      }\n      return result\n    },\n    {\n      key: 'count',\n      size: [],\n      count: []\n    }\n  )\n\n  // insert gap values\n  if (gap) {\n    size = size.filter(i => i.trim())\n    let val = []\n    for (let i = 1; i <= count; i++) {\n      size.forEach((item, index) => {\n        if (index > 0 || i > 1) {\n          val.push(gap)\n        }\n        val.push(item)\n      })\n    }\n\n    return val.join(' ')\n  }\n\n  return `(${size.join('')})[${count.join('')}]`\n}\n\nexports.prefixTrackValue = prefixTrackValue\n\nfunction prefixTrackValue({ value, gap }) {\n  let result = parser(value).nodes.reduce((nodes, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, { gap })\n      })\n    }\n    if (gap && node.type === 'space') {\n      return nodes.concat(\n        {\n          type: 'space',\n          value: ' '\n        },\n        {\n          type: 'word',\n          value: gap\n        },\n        node\n      )\n    }\n    return nodes.concat(node)\n  }, [])\n\n  return parser.stringify(result)\n}\n\n// Parse grid-template-areas\n\nlet DOTS = /^\\.+$/\n\nfunction track(start, end) {\n  return { start, end, span: end - start }\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g)\n}\n\nexports.parseGridAreas = parseGridAreas\n\nfunction parseGridAreas({ rows, gap }) {\n  return rows.reduce((areas, line, rowIndex) => {\n    if (gap.row) rowIndex *= 2\n\n    if (line.trim() === '') return areas\n\n    getColumns(line).forEach((area, columnIndex) => {\n      if (DOTS.test(area)) return\n\n      if (gap.column) columnIndex *= 2\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        }\n      } else {\n        let { column, row } = areas[area]\n\n        column.start = Math.min(column.start, columnIndex + 1)\n        column.end = Math.max(column.end, columnIndex + 2)\n        column.span = column.end - column.start\n\n        row.start = Math.min(row.start, rowIndex + 1)\n        row.end = Math.max(row.end, rowIndex + 2)\n        row.span = row.end - row.start\n      }\n    })\n\n    return areas\n  }, {})\n}\n\n// Parse grid-template\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value)\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto')\n  }\n  return result\n}\n\nexports.parseTemplate = parseTemplate\n\nfunction parseTemplate({ decl, gap }) {\n  let gridTemplate = parser(decl.value).nodes.reduce(\n    (result, node) => {\n      let { type, value } = node\n\n      if (testTrack(node) || type === 'space') return result\n\n      // area\n      if (type === 'string') {\n        result = verifyRowSize(result)\n        result.areas.push(value)\n      }\n\n      // values and function\n      if (type === 'word' || type === 'function') {\n        result[result.key].push(parser.stringify(node))\n      }\n\n      // divider(/)\n      if (type === 'div' && value === '/') {\n        result.key = 'columns'\n        result = verifyRowSize(result)\n      }\n\n      return result\n    },\n    {\n      key: 'rows',\n      columns: [],\n      rows: [],\n      areas: []\n    }\n  )\n\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  }\n}\n\n// Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\nfunction getMSDecls(area, addRowSpan = false, addColumnSpan = false) {\n  let result = [\n    {\n      prop: '-ms-grid-row',\n      value: String(area.row.start)\n    }\n  ]\n  if (area.row.span > 1 || addRowSpan) {\n    result.push({\n      prop: '-ms-grid-row-span',\n      value: String(area.row.span)\n    })\n  }\n  result.push({\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  })\n  if (area.column.span > 1 || addColumnSpan) {\n    result.push({\n      prop: '-ms-grid-column-span',\n      value: String(area.column.span)\n    })\n  }\n  return result\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent\n  }\n  if (!parent.parent) {\n    return false\n  }\n  return getParentMedia(parent.parent)\n}\n\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(selector => {\n    let selectorBySpace = list.space(selector)\n    let selectorByComma = list.comma(selector)\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('')\n    }\n    return selector\n  })\n\n  return ruleSelectors.map(ruleSelector => {\n    let newSelector = templateSelectors.map((tplSelector, index) => {\n      let space = index === 0 ? '' : ' '\n      return `${space}${tplSelector} > ${ruleSelector}`\n    })\n\n    return newSelector\n  })\n}\n\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(sel => {\n    return ruleB.selectors.includes(sel)\n  })\n}\n\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\nfunction parseGridTemplatesData(css) {\n  let parsed = []\n\n  // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n  css.walkDecls(/grid-template(-areas)?$/, d => {\n    let rule = d.parent\n    let media = getParentMedia(rule)\n    let gap = getGridGap(d)\n    let inheritedGap = inheritGridGap(d, gap)\n    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })\n    let areaNames = Object.keys(areas)\n\n    // skip node if it doesn't have areas\n    if (areaNames.length === 0) {\n      return true\n    }\n\n    // check parsed array for item that include the same area names\n    // return index of that item\n    let index = parsed.reduce((acc, { allAreas }, idx) => {\n      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))\n      return hasAreas ? idx : acc\n    }, null)\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      let { allAreas, rules } = parsed[index]\n\n      // check if rule has no duplicate area names\n      let hasNoDuplicates = rules.some(r => {\n        return r.hasDuplicates === false && selectorsEqual(r, rule)\n      })\n\n      let duplicatesFound = false\n\n      // check need to gather all duplicate area names\n      let duplicateAreaNames = rules.reduce((acc, r) => {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true\n          return r.duplicateAreaNames\n        }\n        if (!duplicatesFound) {\n          areaNames.forEach(name => {\n            if (r.areas[name]) {\n              acc.push(name)\n            }\n          })\n        }\n        return uniq(acc)\n      }, [])\n\n      // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n      rules.forEach(r => {\n        areaNames.forEach(name => {\n          let area = r.areas[name]\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true\n          }\n        })\n      })\n\n      parsed[index].allAreas = uniq([...allAreas, ...areaNames])\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames,\n        areas\n      })\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [\n          {\n            hasDuplicates: false,\n            duplicateRules: [],\n            params: media.params,\n            selectors: rule.selectors,\n            node: rule,\n            duplicateAreaNames: [],\n            areas\n          }\n        ]\n      })\n    }\n\n    return undefined\n  })\n\n  return parsed\n}\n\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\nexports.insertAreas = insertAreas\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  let gridTemplatesData = parseGridTemplatesData(css)\n\n  // return undefined if no declarations found\n  if (gridTemplatesData.length === 0) {\n    return undefined\n  }\n\n  // we need to store the rules that we will insert later\n  let rulesToInsert = {}\n\n  css.walkDecls('grid-area', gridArea => {\n    let gridAreaRule = gridArea.parent\n    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'\n    let gridAreaMedia = getParentMedia(gridAreaRule)\n\n    if (isDisabled(gridArea)) {\n      return undefined\n    }\n\n    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)\n\n    let value = gridArea.value\n    // found the data that matches grid-area identifier\n    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]\n\n    if (!data) {\n      return true\n    }\n\n    let lastArea = data.allAreas[data.allAreas.length - 1]\n    let selectorBySpace = list.space(gridAreaRule.selector)\n    let selectorByComma = list.comma(gridAreaRule.selector)\n    let selectorIsComplex =\n      selectorBySpace.length > 1 &&\n      selectorBySpace.length > selectorByComma.length\n\n    // prevent doubling of prefixes\n    if (hasPrefixedRow) {\n      return false\n    }\n\n    // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {}\n    }\n\n    let lastRuleIsSet = false\n\n    // walk through every grid-template rule data\n    for (let rule of data.rules) {\n      let area = rule.areas[value]\n      let hasDuplicateName = rule.duplicateAreaNames.includes(value)\n\n      // if we can't find the area name, update lastRule and continue\n      if (!area) {\n        let lastRule = rulesToInsert[lastArea].lastRule\n        let lastRuleIndex\n        if (lastRule) {\n          lastRuleIndex = css.index(lastRule)\n        } else {\n          /* c8 ignore next 2 */\n          lastRuleIndex = -1\n        }\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n        continue\n      }\n\n      // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = []\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n\n        getMSDecls(area, false, false)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        rulesToInsert[lastArea].lastRule = gridAreaRule\n        lastRuleIsSet = true\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        // grid-template has duplicates and not inside media rule\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        cloned.selectors = changeDuplicateAreaSelectors(\n          cloned.selectors,\n          rule.selectors\n        )\n\n        if (rulesToInsert[lastArea].lastRule) {\n          rulesToInsert[lastArea].lastRule.after(cloned)\n        }\n        rulesToInsert[lastArea].lastRule = cloned\n        lastRuleIsSet = true\n      } else if (\n        rule.hasDuplicates &&\n        !rule.params &&\n        selectorIsComplex &&\n        gridAreaRule.selector.includes(rule.selectors[0])\n      ) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n      } else if (rule.params) {\n        // grid-template is inside media rule\n        // if we're inside media rule, we need to store prefixed rules\n        // inside rulesToInsert object to be able to preserve the order of media\n        // rules and merge them easily\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        if (rule.hasDuplicates && hasDuplicateName) {\n          cloned.selectors = changeDuplicateAreaSelectors(\n            cloned.selectors,\n            rule.selectors\n          )\n        }\n\n        cloned.raws = rule.node.raws\n\n        if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n          // append the prefixed rules right inside media rule\n          // with grid-template\n          rule.node.parent.append(cloned)\n        } else {\n          // store the rule to insert later\n          rulesToInsert[lastArea][rule.params].push(cloned)\n        }\n\n        // set new rule as last rule ONLY if we didn't set lastRule for\n        // this grid-area before\n        if (!lastRuleIsSet) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n      }\n    }\n\n    return undefined\n  })\n\n  // append stored rules inside the media rules\n  Object.keys(rulesToInsert).forEach(area => {\n    let data = rulesToInsert[area]\n    let lastRule = data.lastRule\n    Object.keys(data)\n      .reverse()\n      .filter(p => p !== 'lastRule')\n      .forEach(params => {\n        if (data[params].length > 0 && lastRule) {\n          lastRule.after({ name: 'media', params })\n          lastRule.next().append(data[params])\n        }\n      })\n  })\n\n  return undefined\n}\n\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnMissedAreas = warnMissedAreas\n\nfunction warnMissedAreas(areas, decl, result) {\n  let missed = Object.keys(areas)\n\n  decl.root().walkDecls('grid-area', gridArea => {\n    missed = missed.filter(e => e !== gridArea.value)\n  })\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))\n  }\n\n  return undefined\n}\n\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  let rule = decl.parent\n  let root = decl.root()\n  let duplicatesFound = false\n\n  // slice selector array. Remove the last part (for comparison)\n  let slicedSelectorArr = list\n    .space(rule.selector)\n    .filter(str => str !== '>')\n    .slice(0, -1)\n\n  // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n  if (slicedSelectorArr.length > 0) {\n    let gridTemplateFound = false\n    let foundAreaSelector = null\n\n    root.walkDecls(/grid-template(-areas)?$/, d => {\n      let parent = d.parent\n      let templateSelectors = parent.selectors\n\n      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })\n      let hasArea = areas[decl.value]\n\n      // find the the matching selectors\n      for (let tplSelector of templateSelectors) {\n        if (gridTemplateFound) {\n          break\n        }\n        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')\n\n        gridTemplateFound = tplSelectorArr.every(\n          (item, idx) => item === slicedSelectorArr[idx]\n        )\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector\n      }\n\n      // if we found the duplicate area with different selector\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true\n      }\n\n      return undefined\n    })\n\n    // warn user if we didn't find template\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(\n        result,\n        'Autoprefixer cannot find a grid-template ' +\n          `containing the duplicate grid-area \"${decl.value}\" ` +\n          `with full selector matching: ${slicedSelectorArr.join(' ')}`\n      )\n    }\n  }\n}\n\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnIfGridRowColumnExists = warnIfGridRowColumnExists\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  let rule = decl.parent\n  let decls = []\n  rule.walkDecls(/^grid-(row|column)/, d => {\n    if (\n      !d.prop.endsWith('-end') &&\n      !d.value.startsWith('span') &&\n      !d.prop.endsWith('-gap')\n    ) {\n      decls.push(d)\n    }\n  })\n  if (decls.length > 0) {\n    decls.forEach(d => {\n      d.warn(\n        result,\n        'You already have a grid-area declaration present in the rule. ' +\n          `You should use either grid-area or ${d.prop}, not both`\n      )\n    })\n  }\n\n  return undefined\n}\n\n// Gap utils\n\nexports.getGridGap = getGridGap\n\nfunction getGridGap(decl) {\n  let gap = {}\n\n  // try to find gap\n  let testGap = /^(grid-)?((row|column)-)?gap$/\n  decl.parent.walkDecls(testGap, ({ prop, value }) => {\n    if (/^(grid-)?gap$/.test(prop)) {\n      let [row, , column] = parser(value).nodes\n\n      gap.row = row && parser.stringify(row)\n      gap.column = column ? parser.stringify(column) : gap.row\n    }\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value\n  })\n\n  return gap\n}\n\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\nfunction parseMediaParams(params) {\n  if (!params) {\n    return []\n  }\n  let parsed = parser(params)\n  let prop\n  let value\n\n  parsed.walk(node => {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''))\n    }\n  })\n\n  return [prop, value]\n}\n\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\nfunction shouldInheritGap(selA, selB) {\n  let result\n\n  // get arrays of selector split in 3-deep array\n  let splitSelectorArrA = splitSelector(selA)\n  let splitSelectorArrB = splitSelector(selB)\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n\n    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {\n      let firstSelectorPart = splitSelectorArrB[0][0][0]\n      if (item === firstSelectorPart) {\n        return index\n      }\n      return false\n    }, false)\n\n    if (idx) {\n      result = splitSelectorArrB[0].every((arr, index) => {\n        return arr.every(\n          (part, innerIndex) =>\n            // because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n        )\n      })\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(byCommaArr => {\n      return byCommaArr.every((bySpaceArr, index) => {\n        return bySpaceArr.every(\n          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part\n        )\n      })\n    })\n  }\n\n  return result\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\nexports.inheritGridGap = inheritGridGap\n\nfunction inheritGridGap(decl, gap) {\n  let rule = decl.parent\n  let mediaRule = getParentMedia(rule)\n  let root = rule.root()\n\n  // get an array of selector split in 3-deep array\n  let splitSelectorArr = splitSelector(rule.selector)\n\n  // abort if the rule already has gaps\n  if (Object.keys(gap).length > 0) {\n    return false\n  }\n\n  // e.g ['min-width']\n  let [prop] = parseMediaParams(mediaRule.params)\n\n  let lastBySpace = splitSelectorArr[0]\n\n  // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])\n\n  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)\n\n  // find the closest rule with the same selector\n  let closestRuleGap\n  root.walkRules(regexp, r => {\n    let gridGap\n\n    // abort if are checking the same rule\n    if (rule.toString() === r.toString()) {\n      return false\n    }\n\n    // find grid-gap values\n    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))\n\n    // skip rule without gaps\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true\n    }\n\n    // skip rules that should not be inherited from\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true\n    }\n\n    let media = getParentMedia(r)\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      let propToCompare = parseMediaParams(media.params)[0]\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap\n        return true\n      }\n    } else {\n      closestRuleGap = gridGap\n      return true\n    }\n\n    return undefined\n  })\n\n  // if we find the closest gap object\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap\n  }\n  return false\n}\n\nexports.warnGridGap = warnGridGap\n\nfunction warnGridGap({ gap, hasColumns, decl, result }) {\n  let hasBothGaps = gap.row && gap.column\n  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {\n    delete gap.column\n    decl.warn(\n      result,\n      'Can not implement grid-gap without grid-template-columns'\n    )\n  }\n}\n\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\nfunction normalizeRowColumn(str) {\n  let normalized = parser(str).nodes.reduce((result, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      let key = 'count'\n\n      let [count, value] = node.nodes.reduce(\n        (acc, n) => {\n          if (n.type === 'word' && key === 'count') {\n            acc[0] = Math.abs(parseInt(n.value))\n            return acc\n          }\n          if (n.type === 'div' && n.value === ',') {\n            key = 'value'\n            return acc\n          }\n          if (key === 'value') {\n            acc[1] += parser.stringify(n)\n          }\n          return acc\n        },\n        [0, '']\n      )\n\n      if (count) {\n        for (let i = 0; i < count; i++) {\n          result.push(value)\n        }\n      }\n\n      return result\n    }\n    if (node.type === 'space') {\n      return result\n    }\n    return result.concat(parser.stringify(node))\n  }, [])\n\n  return normalized\n}\n\nexports.autoplaceGridItems = autoplaceGridItems\n\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\nfunction autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {\n  let { parent } = decl\n\n  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')\n  let rows = normalizeRowColumn(rowDecl.value)\n  let columns = normalizeRowColumn(decl.value)\n\n  // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n  let filledRows = rows.map((_, rowIndex) => {\n    return Array.from(\n      { length: columns.length },\n      (v, k) => k + rowIndex * columns.length + 1\n    ).join(' ')\n  })\n\n  let areas = parseGridAreas({ rows: filledRows, gap })\n  let keys = Object.keys(areas)\n  let items = keys.map(i => areas[i])\n\n  // Change the order of cells if grid-auto-flow value is 'column'\n  if (autoflowValue.includes('column')) {\n    items = items.sort((a, b) => a.column.start - b.column.start)\n  }\n\n  // Insert new rules\n  items.reverse().forEach((item, index) => {\n    let { column, row } = item\n    let nodeSelector = parent.selectors\n      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)\n      .join(', ')\n\n    // create new rule\n    let node = parent.clone().removeAll()\n\n    // change rule selector\n    node.selector = nodeSelector\n\n    // insert prefixed row/column values\n    node.append({ prop: '-ms-grid-row', value: row.start })\n    node.append({ prop: '-ms-grid-column', value: column.start })\n\n    // insert rule\n    parent.after(node)\n  })\n\n  return undefined\n}\n","let Declaration = require('../declaration')\n\nclass ImageRendering extends Declaration {\n  /**\n   * Add hack only for crisp-edges\n   */\n  check(decl) {\n    return decl.value === 'pixelated'\n  }\n\n  /**\n   * Change property name for IE\n   */\n  prefixed(prop, prefix) {\n    if (prefix === '-ms-') {\n      return '-ms-interpolation-mode'\n    }\n    return super.prefixed(prop, prefix)\n  }\n\n  /**\n   * Change property and value for IE\n   */\n  set(decl, prefix) {\n    if (prefix !== '-ms-') return super.set(decl, prefix)\n    decl.prop = '-ms-interpolation-mode'\n    decl.value = 'nearest-neighbor'\n    return decl\n  }\n\n  /**\n   * Return property name by spec\n   */\n  normalize() {\n    return 'image-rendering'\n  }\n\n  /**\n   * Warn on old value\n   */\n  process(node, result) {\n    return super.process(node, result)\n  }\n}\n\nImageRendering.names = ['image-rendering', 'interpolation-mode']\n\nmodule.exports = ImageRendering\n","let Value = require('../value')\n\nclass ImageSet extends Value {\n  /**\n   * Use non-standard name for WebKit and Firefox\n   */\n  replace(string, prefix) {\n    let fixed = super.replace(string, prefix)\n    if (prefix === '-webkit-') {\n      fixed = fixed.replace(/(\"[^\"]+\"|'[^']+')(\\s+\\d+\\w)/gi, 'url($1)$2')\n    }\n    return fixed\n  }\n}\n\nImageSet.names = ['image-set']\n\nmodule.exports = ImageSet\n","let Declaration = require('../declaration')\n\nclass InlineLogical extends Declaration {\n  /**\n   * Use old syntax for -moz- and -webkit-\n   */\n  prefixed(prop, prefix) {\n    return prefix + prop.replace('-inline', '')\n  }\n\n  /**\n   * Return property name by spec\n   */\n  normalize(prop) {\n    return prop.replace(/(margin|padding|border)-(start|end)/, '$1-inline-$2')\n  }\n}\n\nInlineLogical.names = [\n  'border-inline-start',\n  'border-inline-end',\n  'margin-inline-start',\n  'margin-inline-end',\n  'padding-inline-start',\n  'padding-inline-end',\n  'border-start',\n  'border-end',\n  'margin-start',\n  'margin-end',\n  'padding-start',\n  'padding-end'\n]\n\nmodule.exports = InlineLogical\n","let OldValue = require('../old-value')\nlet Value = require('../value')\n\nfunction regexp(name) {\n  return new RegExp(`(^|[\\\\s,(])(${name}($|[\\\\s),]))`, 'gi')\n}\n\nclass Intrinsic extends Value {\n  regexp() {\n    if (!this.regexpCache) this.regexpCache = regexp(this.name)\n    return this.regexpCache\n  }\n\n  isStretch() {\n    return (\n      this.name === 'stretch' ||\n      this.name === 'fill' ||\n      this.name === 'fill-available'\n    )\n  }\n\n  replace(string, prefix) {\n    if (prefix === '-moz-' && this.isStretch()) {\n      return string.replace(this.regexp(), '$1-moz-available$3')\n    }\n    if (prefix === '-webkit-' && this.isStretch()) {\n      return string.replace(this.regexp(), '$1-webkit-fill-available$3')\n    }\n    return super.replace(string, prefix)\n  }\n\n  old(prefix) {\n    let prefixed = prefix + this.name\n    if (this.isStretch()) {\n      if (prefix === '-moz-') {\n        prefixed = '-moz-available'\n      } else if (prefix === '-webkit-') {\n        prefixed = '-webkit-fill-available'\n      }\n    }\n    return new OldValue(this.name, prefixed, prefixed, regexp(prefixed))\n  }\n\n  add(decl, prefix) {\n    if (decl.prop.includes('grid') && prefix !== '-webkit-') {\n      return undefined\n    }\n    return super.add(decl, prefix)\n  }\n}\n\nIntrinsic.names = [\n  'max-content',\n  'min-content',\n  'fit-content',\n  'fill',\n  'fill-available',\n  'stretch'\n]\n\nmodule.exports = Intrinsic\n","let flexSpec = require('./flex-spec')\nlet Declaration = require('../declaration')\n\nclass JustifyContent extends Declaration {\n  /**\n   * Change property name for 2009 and 2012 specs\n   */\n  prefixed(prop, prefix) {\n    let spec\n    ;[spec, prefix] = flexSpec(prefix)\n    if (spec === 2009) {\n      return prefix + 'box-pack'\n    }\n    if (spec === 2012) {\n      return prefix + 'flex-pack'\n    }\n    return super.prefixed(prop, prefix)\n  }\n\n  /**\n   * Return property name by final spec\n   */\n  normalize() {\n    return 'justify-content'\n  }\n\n  /**\n   * Change value for 2009 and 2012 specs\n   */\n  set(decl, prefix) {\n    let spec = flexSpec(prefix)[0]\n    if (spec === 2009 || spec === 2012) {\n      let value = JustifyContent.oldValues[decl.value] || decl.value\n      decl.value = value\n      if (spec !== 2009 || value !== 'distribute') {\n        return super.set(decl, prefix)\n      }\n    } else if (spec === 'final') {\n      return super.set(decl, prefix)\n    }\n    return undefined\n  }\n}\n\nJustifyContent.names = ['justify-content', 'flex-pack', 'box-pack']\n\nJustifyContent.oldValues = {\n  'flex-end': 'end',\n  'flex-start': 'start',\n  'space-between': 'justify',\n  'space-around': 'distribute'\n}\n\nmodule.exports = JustifyContent\n","let Declaration = require('../declaration')\n\nclass MaskBorder extends Declaration {\n  /**\n   * Return property name by final spec\n   */\n  normalize() {\n    return this.name.replace('box-image', 'border')\n  }\n\n  /**\n   * Return flex property for 2012 spec\n   */\n  prefixed(prop, prefix) {\n    let result = super.prefixed(prop, prefix)\n    if (prefix === '-webkit-') {\n      result = result.replace('border', 'box-image')\n    }\n    return result\n  }\n}\n\nMaskBorder.names = [\n  'mask-border',\n  'mask-border-source',\n  'mask-border-slice',\n  'mask-border-width',\n  'mask-border-outset',\n  'mask-border-repeat',\n  'mask-box-image',\n  'mask-box-image-source',\n  'mask-box-image-slice',\n  'mask-box-image-width',\n  'mask-box-image-outset',\n  'mask-box-image-repeat'\n]\n\nmodule.exports = MaskBorder\n","let Declaration = require('../declaration')\n\nclass MaskComposite extends Declaration {\n  /**\n   * Prefix mask-composite for webkit\n   */\n  insert(decl, prefix, prefixes) {\n    let isCompositeProp = decl.prop === 'mask-composite'\n\n    let compositeValues\n\n    if (isCompositeProp) {\n      compositeValues = decl.value.split(',')\n    } else {\n      compositeValues = decl.value.match(MaskComposite.regexp) || []\n    }\n\n    compositeValues = compositeValues.map(el => el.trim()).filter(el => el)\n    let hasCompositeValues = compositeValues.length\n\n    let compositeDecl\n\n    if (hasCompositeValues) {\n      compositeDecl = this.clone(decl)\n      compositeDecl.value = compositeValues\n        .map(value => MaskComposite.oldValues[value] || value)\n        .join(', ')\n\n      if (compositeValues.includes('intersect')) {\n        compositeDecl.value += ', xor'\n      }\n\n      compositeDecl.prop = prefix + 'mask-composite'\n    }\n\n    if (isCompositeProp) {\n      if (!hasCompositeValues) {\n        return undefined\n      }\n\n      if (this.needCascade(decl)) {\n        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)\n      }\n\n      return decl.parent.insertBefore(decl, compositeDecl)\n    }\n\n    let cloned = this.clone(decl)\n    cloned.prop = prefix + cloned.prop\n\n    if (hasCompositeValues) {\n      cloned.value = cloned.value.replace(MaskComposite.regexp, '')\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\n    }\n\n    decl.parent.insertBefore(decl, cloned)\n\n    if (!hasCompositeValues) {\n      return decl\n    }\n\n    if (this.needCascade(decl)) {\n      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)\n    }\n    return decl.parent.insertBefore(decl, compositeDecl)\n  }\n}\n\nMaskComposite.names = ['mask', 'mask-composite']\n\nMaskComposite.oldValues = {\n  add: 'source-over',\n  subtract: 'source-out',\n  intersect: 'source-in',\n  exclude: 'xor'\n}\n\nMaskComposite.regexp = new RegExp(\n  `\\\\s+(${Object.keys(MaskComposite.oldValues).join(\n    '|'\n  )})\\\\b(?!\\\\))\\\\s*(?=[,])`,\n  'ig'\n)\n\nmodule.exports = MaskComposite\n","let flexSpec = require('./flex-spec')\nlet Declaration = require('../declaration')\n\nclass Order extends Declaration {\n  /**\n   * Change property name for 2009 and 2012 specs\n   */\n  prefixed(prop, prefix) {\n    let spec\n    ;[spec, prefix] = flexSpec(prefix)\n    if (spec === 2009) {\n      return prefix + 'box-ordinal-group'\n    }\n    if (spec === 2012) {\n      return prefix + 'flex-order'\n    }\n    return super.prefixed(prop, prefix)\n  }\n\n  /**\n   * Return property name by final spec\n   */\n  normalize() {\n    return 'order'\n  }\n\n  /**\n   * Fix value for 2009 spec\n   */\n  set(decl, prefix) {\n    let spec = flexSpec(prefix)[0]\n    if (spec === 2009 && /\\d/.test(decl.value)) {\n      decl.value = (parseInt(decl.value) + 1).toString()\n      return super.set(decl, prefix)\n    }\n    return super.set(decl, prefix)\n  }\n}\n\nOrder.names = ['order', 'flex-order', 'box-ordinal-group']\n\nmodule.exports = Order\n","let Declaration = require('../declaration')\n\nclass OverscrollBehavior extends Declaration {\n  /**\n   * Change property name for IE\n   */\n  prefixed(prop, prefix) {\n    return prefix + 'scroll-chaining'\n  }\n\n  /**\n   * Return property name by spec\n   */\n  normalize() {\n    return 'overscroll-behavior'\n  }\n\n  /**\n   * Change value for IE\n   */\n  set(decl, prefix) {\n    if (decl.value === 'auto') {\n      decl.value = 'chained'\n    } else if (decl.value === 'none' || decl.value === 'contain') {\n      decl.value = 'none'\n    }\n    return super.set(decl, prefix)\n  }\n}\n\nOverscrollBehavior.names = ['overscroll-behavior', 'scroll-chaining']\n\nmodule.exports = OverscrollBehavior\n","let OldValue = require('../old-value')\nlet Value = require('../value')\n\nclass Pixelated extends Value {\n  /**\n   * Use non-standard name for WebKit and Firefox\n   */\n  replace(string, prefix) {\n    if (prefix === '-webkit-') {\n      return string.replace(this.regexp(), '$1-webkit-optimize-contrast')\n    }\n    if (prefix === '-moz-') {\n      return string.replace(this.regexp(), '$1-moz-crisp-edges')\n    }\n    return super.replace(string, prefix)\n  }\n\n  /**\n   * Different name for WebKit and Firefox\n   */\n  old(prefix) {\n    if (prefix === '-webkit-') {\n      return new OldValue(this.name, '-webkit-optimize-contrast')\n    }\n    if (prefix === '-moz-') {\n      return new OldValue(this.name, '-moz-crisp-edges')\n    }\n    return super.old(prefix)\n  }\n}\n\nPixelated.names = ['pixelated']\n\nmodule.exports = Pixelated\n","let Declaration = require('../declaration')\nlet utils = require('./grid-utils')\n\nclass PlaceSelf extends Declaration {\n  /**\n   * Translate place-self to separate -ms- prefixed properties\n   */\n  insert(decl, prefix, prefixes) {\n    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)\n\n    // prevent doubling of prefixes\n    if (decl.parent.some(i => i.prop === '-ms-grid-row-align')) {\n      return undefined\n    }\n\n    let [[first, second]] = utils.parse(decl)\n\n    if (second) {\n      utils.insertDecl(decl, 'grid-row-align', first)\n      utils.insertDecl(decl, 'grid-column-align', second)\n    } else {\n      utils.insertDecl(decl, 'grid-row-align', first)\n      utils.insertDecl(decl, 'grid-column-align', first)\n    }\n\n    return undefined\n  }\n}\n\nPlaceSelf.names = ['place-self']\n\nmodule.exports = PlaceSelf\n","let Selector = require('../selector')\n\nclass PlaceholderShown extends Selector {\n  /**\n   * Return different selectors depend on prefix\n   */\n  prefixed(prefix) {\n    if (prefix === '-ms-') {\n      return ':-ms-input-placeholder'\n    }\n    return `:${prefix}placeholder-shown`\n  }\n}\n\nPlaceholderShown.names = [':placeholder-shown']\n\nmodule.exports = PlaceholderShown\n","let Selector = require('../selector')\n\nclass Placeholder extends Selector {\n  /**\n   * Add old mozilla to possible prefixes\n   */\n  possible() {\n    return super.possible().concat(['-moz- old', '-ms- old'])\n  }\n\n  /**\n   * Return different selectors depend on prefix\n   */\n  prefixed(prefix) {\n    if (prefix === '-webkit-') {\n      return '::-webkit-input-placeholder'\n    }\n    if (prefix === '-ms-') {\n      return '::-ms-input-placeholder'\n    }\n    if (prefix === '-ms- old') {\n      return ':-ms-input-placeholder'\n    }\n    if (prefix === '-moz- old') {\n      return ':-moz-placeholder'\n    }\n    return `::${prefix}placeholder`\n  }\n}\n\nPlaceholder.names = ['::placeholder']\n\nmodule.exports = Placeholder\n","let Declaration = require('../declaration')\n\nclass PrintColorAdjust extends Declaration {\n  /**\n   * Change property name for WebKit-based browsers\n   */\n  prefixed(prop, prefix) {\n    if (prefix === '-moz-') {\n      return 'color-adjust'\n    } else {\n      return prefix + 'print-color-adjust'\n    }\n  }\n\n  /**\n   * Return property name by spec\n   */\n  normalize() {\n    return 'print-color-adjust'\n  }\n}\n\nPrintColorAdjust.names = ['print-color-adjust', 'color-adjust']\n\nmodule.exports = PrintColorAdjust\n","let Declaration = require('../declaration')\n\nclass TextDecorationSkipInk extends Declaration {\n  /**\n   * Change prefix for ink value\n   */\n  set(decl, prefix) {\n    if (decl.prop === 'text-decoration-skip-ink' && decl.value === 'auto') {\n      decl.prop = prefix + 'text-decoration-skip'\n      decl.value = 'ink'\n      return decl\n    } else {\n      return super.set(decl, prefix)\n    }\n  }\n}\n\nTextDecorationSkipInk.names = [\n  'text-decoration-skip-ink',\n  'text-decoration-skip'\n]\n\nmodule.exports = TextDecorationSkipInk\n","let Declaration = require('../declaration')\n\nconst BASIC = [\n  'none',\n  'underline',\n  'overline',\n  'line-through',\n  'blink',\n  'inherit',\n  'initial',\n  'unset'\n]\n\nclass TextDecoration extends Declaration {\n  /**\n   * Do not add prefixes for basic values.\n   */\n  check(decl) {\n    return decl.value.split(/\\s+/).some(i => !BASIC.includes(i))\n  }\n}\n\nTextDecoration.names = ['text-decoration']\n\nmodule.exports = TextDecoration\n","let Declaration = require('../declaration')\n\nclass TextEmphasisPosition extends Declaration {\n  set(decl, prefix) {\n    if (prefix === '-webkit-') {\n      decl.value = decl.value.replace(/\\s*(right|left)\\s*/i, '')\n    }\n    return super.set(decl, prefix)\n  }\n}\n\nTextEmphasisPosition.names = ['text-emphasis-position']\n\nmodule.exports = TextEmphasisPosition\n","let Declaration = require('../declaration')\n\nclass TransformDecl extends Declaration {\n  /**\n   * Recursively check all parents for @keyframes\n   */\n  keyframeParents(decl) {\n    let { parent } = decl\n    while (parent) {\n      if (parent.type === 'atrule' && parent.name === 'keyframes') {\n        return true\n      }\n      ;({ parent } = parent)\n    }\n    return false\n  }\n\n  /**\n   * Is transform contain 3D commands\n   */\n  contain3d(decl) {\n    if (decl.prop === 'transform-origin') {\n      return false\n    }\n\n    for (let func of TransformDecl.functions3d) {\n      if (decl.value.includes(`${func}(`)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Replace rotateZ to rotate for IE 9\n   */\n  set(decl, prefix) {\n    decl = super.set(decl, prefix)\n    if (prefix === '-ms-') {\n      decl.value = decl.value.replace(/rotatez/gi, 'rotate')\n    }\n    return decl\n  }\n\n  /**\n   * Don't add prefix for IE in keyframes\n   */\n  insert(decl, prefix, prefixes) {\n    if (prefix === '-ms-') {\n      if (!this.contain3d(decl) && !this.keyframeParents(decl)) {\n        return super.insert(decl, prefix, prefixes)\n      }\n    } else if (prefix === '-o-') {\n      if (!this.contain3d(decl)) {\n        return super.insert(decl, prefix, prefixes)\n      }\n    } else {\n      return super.insert(decl, prefix, prefixes)\n    }\n    return undefined\n  }\n}\n\nTransformDecl.names = ['transform', 'transform-origin']\n\nTransformDecl.functions3d = [\n  'matrix3d',\n  'translate3d',\n  'translateZ',\n  'scale3d',\n  'scaleZ',\n  'rotate3d',\n  'rotateX',\n  'rotateY',\n  'perspective'\n]\n\nmodule.exports = TransformDecl\n","let Declaration = require('../declaration')\n\nclass UserSelect extends Declaration {\n  /**\n   * Change prefixed value for IE\n   */\n  set(decl, prefix) {\n    if (prefix === '-ms-' && decl.value === 'contain') {\n      decl.value = 'element'\n    }\n    return super.set(decl, prefix)\n  }\n\n  /**\n   * Avoid prefixing all in IE\n   */\n  insert(decl, prefix, prefixes) {\n    if (decl.value === 'all' && prefix === '-ms-') {\n      return undefined\n    } else {\n      return super.insert(decl, prefix, prefixes)\n    }\n  }\n}\n\nUserSelect.names = ['user-select']\n\nmodule.exports = UserSelect\n","let Declaration = require('../declaration')\n\nclass WritingMode extends Declaration {\n  insert(decl, prefix, prefixes) {\n    if (prefix === '-ms-') {\n      let cloned = this.set(this.clone(decl), prefix)\n\n      if (this.needCascade(decl)) {\n        cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\n      }\n      let direction = 'ltr'\n\n      decl.parent.nodes.forEach(i => {\n        if (i.prop === 'direction') {\n          if (i.value === 'rtl' || i.value === 'ltr') direction = i.value\n        }\n      })\n\n      cloned.value = WritingMode.msValues[direction][decl.value] || decl.value\n      return decl.parent.insertBefore(decl, cloned)\n    }\n\n    return super.insert(decl, prefix, prefixes)\n  }\n}\n\nWritingMode.names = ['writing-mode']\n\nWritingMode.msValues = {\n  ltr: {\n    'horizontal-tb': 'lr-tb',\n    'vertical-rl': 'tb-rl',\n    'vertical-lr': 'tb-lr'\n  },\n  rtl: {\n    'horizontal-tb': 'rl-tb',\n    'vertical-rl': 'bt-rl',\n    'vertical-lr': 'bt-lr'\n  }\n}\n\nmodule.exports = WritingMode\n"],"names":["Declaration","GridRowAlign","check","decl","value","includes","prefixed","prop","prefix","normalize","names","module","exports","utils","GridRowColumn","insert","prefixes","super","values","parse","start","span","translate","join","replace","forEach","insertDecl","prefixTrackProp","prefixTrackValue","autoplaceGridItems","getGridGap","inheritGridGap","Processor","GridRowsColumns","result","parent","isRowProp","isColumnProp","hasGridTemplate","some","i","processor","options","status","gridStatus","gap","gapValue","row","column","prefixValue","cloneBefore","autoflow","nodes","find","autoflowValue","disabled","trim","rowDecl","warn","GridStart","parseGridAreas","warnMissedAreas","warnGridGap","GridTemplateAreas","hasColumns","hasRows","walkDecls","remove","trackDecl","gridRows","slice","split","length","raws","areas","rows","parseTemplate","GridTemplate","inheritedGap","columns","hasAreas","Object","keys","Boolean","parser","list","uniq","escapeRegexp","splitSelector","convert","parseInt","transformRepeat","count","size","reduce","node","type","key","push","stringify","filter","val","item","index","concat","startIndex","endIndex","startValue","endValue","spanStart","end","spanEnd","current","toString","DOTS","track","line","rowIndex","getColumns","area","columnIndex","test","Math","min","max","verifyRowSize","gridTemplate","testTrack","getMSDecls","addRowSpan","addColumnSpan","String","getParentMedia","name","changeDuplicateAreaSelectors","ruleSelectors","templateSelectors","map","selector","selectorBySpace","space","selectorByComma","comma","ruleSelector","tplSelector","selectorsEqual","ruleA","ruleB","selectors","sel","parseMediaParams","params","walk","rule","mediaRule","root","splitSelectorArr","closestRuleGap","lastBySpace","escaped","regexp","RegExp","walkRules","r","gridGap","d","selA","selB","splitSelectorArrA","splitSelectorArrB","idx","res","every","arr","part","innerIndex","byCommaArr","bySpaceArr","shouldInheritGap","media","undefined","normalizeRowColumn","str","acc","n","abs","insertAreas","css","isDisabled","gridTemplatesData","parsed","areaNames","allAreas","rules","hasNoDuplicates","hasDuplicates","duplicatesFound","duplicateAreaNames","updateSpan","areasCount","duplicateRules","parseGridTemplatesData","rulesToInsert","gridArea","gridAreaRule","hasPrefixedRow","first","gridAreaMedia","gridAreaRuleIndex","data","lastArea","selectorIsComplex","lastRuleIsSet","hasDuplicateName","reverse","prepend","assign","between","cloned","clone","removeAll","append","lastRule","after","lastRuleIndex","p","next","missed","e","warnTemplateSelectorNotFound","slicedSelectorArr","gridTemplateFound","foundAreaSelector","hasArea","tplSelectorArr","warnIfGridRowColumnExists","decls","endsWith","startsWith","hasBothGaps","_","Array","from","v","k","items","sort","a","b","nodeSelector","ImageRendering","set","process","Value","ImageSet","string","fixed","InlineLogical","OldValue","Intrinsic","this","regexpCache","isStretch","old","add","flexSpec","JustifyContent","spec","oldValues","MaskBorder","MaskComposite","compositeValues","isCompositeProp","match","el","compositeDecl","hasCompositeValues","needCascade","before","calcBefore","insertBefore","subtract","intersect","exclude","Order","OverscrollBehavior","Pixelated","PlaceSelf","second","Selector","PlaceholderShown","Placeholder","possible","PrintColorAdjust","TextDecorationSkipInk","BASIC","TextDecoration","TextEmphasisPosition","TransformDecl","keyframeParents","contain3d","func","functions3d","UserSelect","WritingMode","direction","msValues","ltr","rtl"],"sourceRoot":""}